#### 数据类型

在Java中，数据类型只有`四类八种`
* 整数型：byte、short、int、long
* 浮点型：float、double
* 字符型：char
* 布尔型：boolean


| 数据类型 | 内存 | 最小值 | 最大值 | 默认值 |
|--|--|--|--|--|
| byte | 8位 | -128 | 127 | 0 |
| short | 16位 | $-2^{15}$ | $2^{15}-1$ | 0 |
| int  | 32位 | $-2^{31}$ | $2^{31}-1$ | 0 |
| long | 64位 | $-2^{63}$ | $2^{63} - 1$ | 0L |
| float | 32位 | IEEE754 | IEEE754 | 0.0f |
| double | 64位 | IEEE754 | IEEE754 | 0.0d |
| char | 16位 | Unicode 0 | Unicode $2^{16} - 1$ | \u0000 |
| boolean | 8位 | - | - | false |


#### 命名规范

* 类名：对于所有的类来说，首字母应该大写，例如`MyFirstClass`
* 包名：包名应该尽量保证小写，例如`my.first.package`
* 方法名：方法名首字母需要小写，后面每个单词字母都需要大写，例如`myFirstMethod()`

#### 运算符

* **赋值运算符：** 使用`=`来表示，意思为将等号右边的值赋值给等号左边。
* **算术运算符：** `+ - * / %`
* **自增、自减运算符：**
```java
int a = 5;
b = ++a;
c = a++;
```
注意先运算还是先自增即可。
* **比较运算符：** `> < >= <= == !=`
* **逻辑运算符：** 

![](http://blog.tryna.top/img/2022-01-11-16-26-22.png)

* **按位运算符：** 按位运算符用来操作整数基本类型中的每个比特位，也就是二进制位，按位操作符会对两个参数中对应的位执行布尔代数运算，并最终生成一个结果。
  * &（按位与）两个操作数中位都为1，结果才为1，否则结果为0
  * |（按位或）两个操作数中有一位为1，结果为1，否则结果为0
  * ~（按位非）如果位为0，结果为1，如果位为1，结果为0。（数值加1，符号取反）eg: ~4 = -5
  * ^（按位异或）两个操作数的位中相同则结果为0，不同则为1

* **移位运算符：** 移位运算符用来将操作数向某个方向移动指定的二进制位数
    * 右移运算符`>>` eg: $8>>1 = 4$
    * 左移运算符`<<` eg: $9 << 2 = 36$

* **三元运算符：** 三元运算符是类似`if...else...`这种的操作符，语法为`条件表达式？表达式1：表达式2`。问号前的位置是判断的条件，结果为布尔类型，为真时调用表达式1，否则调用表达式2。

#### Java执行控制流程

* **条件语句：** `if语句`，`if...else语句`，`if...else if多支语句`，`switch语句`
* **循环语句：** `while语句`，`do...while语句`，`for循环语句`
  * **for-each：** 在Java JDK 1.5中还引入了一种更加简洁、方便对数组和集合进行遍历的方法。
```java
int array[] = {7, 8, 9}

for(int arr : array) {
    System.out.println(arr);
}
```
* **跳转语句：**
  * **continue:** 指跳出当前的这一次循环，继续下一次循环。
  * **break:** 指跳出整个循环体，继续执行循环下面的语句。
  * **return:** 用于跳出所在方法，结束该方法的运行。

#### 字符型常量与字符串常量的区别？

1. **形式：** 字符常量是单引号引起的一个字符，字符串常量是双引号引起的 0 个或若干个字符
2. **含义:** 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置)
3. **占内存大小：** 字符常量只占 2 个字节; 字符串常量占若干个字节 (注意： char 在 Java 中占两个字节)

#### 可变长参数

从 Java5 开始，Java 支持定义可变长参数，所谓可变长参数就是允许在调用方法时传入不定长度的参数。

```java
public static void method1(String... args) {
   //......
}
```
另外，可变参数只能作为函数的最后一个参数，但其前面可以有也可以没有任何其他参数。
```java
public static void method2(String arg1, String... args) {
   //......
}
```
**遇到方法重载的情况怎么办呢？会优先匹配固定参数还是可变参数的方法呢？**

答案是会优先匹配固定参数的方法，因为固定参数的方法匹配度更高。

我们通过下面这个例子来证明一下。

```java
public class VariableLengthArgument {

    public static void printVariable(String... args) {
        for (String s : args) {
            System.out.println(s);
        }
    }

    public static void printVariable(String arg1, String arg2) {
        System.out.println(arg1 + arg2);
    }

    public static void main(String[] args) {
        printVariable("a", "b");
        printVariable("a", "b", "c", "d");
    }
}
```
输出：
```
ab
a
b
c
d
```




