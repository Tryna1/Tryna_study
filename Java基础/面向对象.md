#### 面向对象与面向过程的区别

* **面向过程 ：** **面向过程性能比面向对象高。** 因为类调用时需要实例化，开销比较大，比较消耗资源，所以当性能是最重要的考量因素的时候，比如单片机、嵌入式开发、Linux/Unix 等一般采用面向过程开发。**但是，面向过程没有面向对象易维护、易复用、易扩展。**
* **面向对象 ：面向对象易维护、易复用、易扩展。** 因为面向对象有封装、继承、多态性的特性，所以可以设计出低耦合的系统，使系统更加灵活、更加易于维护。**但是，面向对象性能比面向过程低。**

**注意：** Java 性能差的主要原因并不是因为它是面向对象语言，而是 Java 是半编译语言，最终的执行代码并不是可以直接被 CPU 执行的二进制机械码。


#### 成员变量与局部变量的区别有哪些？

1.从语法形式上看，成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 `public,private,static` 等修饰符所修饰，而局部变量不能被访问控制修饰符及 `static` 所修饰；但是，成员变量和局部变量都能被 `final` 所修饰。

2.从变量在内存中的存储方式来看,如果成员变量是使用 `static` 修饰的，那么这个成员变量是属于类的，如果没有使用 `static` 修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。

3.从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。

4.从变量是否有默认值来看，成员变量如果没有被赋初，则会自动以类型的默认值而赋值（一种情况例外:被 `final` 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。


#### 创建一个对象用什么运算符?对象实体与对象引用有何不同?

在Java中，万事万物都是对象。尽管一切都看作是对象，但是你操纵的却是一个对象的引用。在这里有一个很形象的比喻：你可以把车钥匙和车看作是一组对象引用和对象的组合。即使没有车，车钥匙也是一个独立存在的实体，也就是说，你有一个对象引用，但你不一定需要一个对象与之关联。

```java
Car carKey;
```

这里创建的只是引用，并非对象，但是如果想要使用这个引用时，会返回一个异常，告诉你需要一个对象来和这个引用进行关联，一种安全的做法是，在创建对象引用的同时把一个对象赋给它。

```java
Car carKey = new Car();
```
在Java中，一旦创建了一个引用，就希望它能与一个新的对象进行关联，通常使用`new`操作符来实现这一目的。


new 运算符，new 创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。

一个对象引用可以指向 0 个或 1 个对象（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有 n 个引用指向它（可以用 n 条绳子系住一个气球）。


#### 对象的相等与指向他们的引用相等,两者有什么不同?

对象的相等，比的是内存中存放的内容是否相等。而引用相等，比较的是他们指向的内存地址是否相等。

#### 一个类的构造方法的作用是什么? 若一个类没有声明构造方法，该程序能正确执行吗? 为什么?

构造方法主要作用是完成对类对象的初始化工作。

如果一个类没有声明构造方法，也可以执行！因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。如果我们自己添加了类的构造方法（无论是否有参），Java 就不会再添加默认的无参数的构造方法了，这时候，就不能直接 new 一个对象而不传递参数了，所以我们一直在不知不觉地使用构造方法，这也是为什么我们在创建对象的时候后面要加一个括号（因为要调用无参的构造方法）。如果我们重载了有参的构造方法，记得都要把无参的构造方法也写出来（无论是否用到），因为这可以帮助我们在创建对象的时候少踩坑。


#### 构造方法有哪些特点？是否可被 override?

**特点：**
* 1.名字与类名相同。
* 2.没有返回值，但不能用 void 声明构造函数。
* 3.生成类的对象时自动执行，无需调用。

构造方法不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况。


#### this和super

this和super都是Java中的关键字

this表示的是当前对象，this可以调用方法、调用属性和指向对象本身。

this在Java中的使用一般有三种：指向当前对象

```java
public class Apple{
    int i = 0;

    Apple eatApple() {
        i++;
        return this;
    }

    public static void main(String[] args) {
        Apple apple = new Apple();
        apple.eatApple().eatApple();
    }
}
```

一个`eatApple()`方法竟然可以调用多次，在后面还可以继续调用，这就很神奇了，为啥呢？其实就是`this`在作祟，我在`eatApple()`方法中加了一个`return this`的返回值，也就是说哪个对象调用`eatApple()`方法都能返回对象的自身。

`this`还可以修饰属性，最常见的就是在构造方法中使用`this`，如下所示

```java
public class Apple{
    private int num;
    
    public Apple(int num) {
        this.num = num;
    }

    public static void main(String[] args) {
        Apple apple = new Apple(10);
    }
}
```

`main` 方法中传递了一个int值为10的参数，并把这个数量赋给了num全局变量。

`this` 还可以和构造函数一起使用，充当一个全局关键字的效果

```java
class Apple{
    private int num;
    private String color;

    public Apple(int num) {
        this(num, "红色");
    }

    public Apple(int num, String color) {
        this.num = num;
        this.color = color;
    }

    public int getNum() {
        return num;
    }

    public String getColor() {
        return color;
    }
}

public class Main {

    public static void main(String[] args) {
        Apple apple = new Apple(10);
        System.out.println(apple.getNum() + "   " + apple.getColor());
    }
}
```

输出：
```
10   红色
```

你会发现上面这段代码使用的不是`this`,而是`this(参数)`。它相当于调用了其他构造方法，然后传递参数进去。**这里值得注意的一点：this()必须放在构造函数的第一行，否则编译不通过。**

如果你把this理解为一个指向自身的一个引用，那么super就是指向父类的一个引用。super关键字和this一样，你可以使用`super.对象`来引用父类的成员。

```java
class Fruit {
    public int num;
    public String color;

    public void eat() {
        System.out.println("eat Fruit");
    }
}

class Apple extends Fruit {

    @Override
    public void eat() {
        super.num = 10;
        System.out.println("eat " + num + " Apple");
    }
}

public class Main {

    public static void main(String[] args) {
        Apple apple = new Apple();
        apple.eat();
    }
}
```

输出：

```
eat 10 Apple
```

同样也可以使用`super(参数)`来调用父类的构造函数。

下面汇总了this关键字和super关键字的比较。

| 关键字 | this | super |
|--|--|--|
| 调用方式 | 调用本类中的属性、构造函数、方法 | 调用父类中的属性、构造函数、方法 |
| 调用位置 | 构造函数第一行，其他可自行指定 | 构造函数第一行，其他可自行指定 |
| 调用次数 | 一个构造函数只能调用一次 | 一个构造函数只能调用一次 |