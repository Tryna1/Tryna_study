#### 面向对象与面向过程的区别

* **面向过程 ：** **面向过程性能比面向对象高。** 因为类调用时需要实例化，开销比较大，比较消耗资源，所以当性能是最重要的考量因素的时候，比如单片机、嵌入式开发、Linux/Unix 等一般采用面向过程开发。**但是，面向过程没有面向对象易维护、易复用、易扩展。**
* **面向对象 ：面向对象易维护、易复用、易扩展。** 因为面向对象有封装、继承、多态性的特性，所以可以设计出低耦合的系统，使系统更加灵活、更加易于维护。**但是，面向对象性能比面向过程低。**

**注意：** Java 性能差的主要原因并不是因为它是面向对象语言，而是 Java 是半编译语言，最终的执行代码并不是可以直接被 CPU 执行的二进制机械码。


#### 成员变量与局部变量的区别有哪些？

1.从语法形式上看，成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 `public,private,static` 等修饰符所修饰，而局部变量不能被访问控制修饰符及 `static` 所修饰；但是，成员变量和局部变量都能被 `final` 所修饰。

2.从变量在内存中的存储方式来看,如果成员变量是使用 `static` 修饰的，那么这个成员变量是属于类的，如果没有使用 `static` 修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。

3.从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。

4.从变量是否有默认值来看，成员变量如果没有被赋初，则会自动以类型的默认值而赋值（一种情况例外:被 `final` 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。


#### 创建一个对象用什么运算符?对象实体与对象引用有何不同?

在Java中，万事万物都是对象。尽管一切都看作是对象，但是你操纵的却是一个对象的引用。在这里有一个很形象的比喻：你可以把车钥匙和车看作是一组对象引用和对象的组合。即使没有车，车钥匙也是一个独立存在的实体，也就是说，你有一个对象引用，但你不一定需要一个对象与之关联。

```java
Car carKey;
```

这里创建的只是引用，并非对象，但是如果想要使用这个引用时，会返回一个异常，告诉你需要一个对象来和这个引用进行关联，一种安全的做法是，在创建对象引用的同时把一个对象赋给它。

```java
Car carKey = new Car();
```
在Java中，一旦创建了一个引用，就希望它能与一个新的对象进行关联，通常使用`new`操作符来实现这一目的。


new 运算符，new 创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。

一个对象引用可以指向 0 个或 1 个对象（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有 n 个引用指向它（可以用 n 条绳子系住一个气球）。


#### 对象的相等与指向他们的引用相等,两者有什么不同?

对象的相等，比的是内存中存放的内容是否相等。而引用相等，比较的是他们指向的内存地址是否相等。

#### 一个类的构造方法的作用是什么? 若一个类没有声明构造方法，该程序能正确执行吗? 为什么?

构造方法主要作用是完成对类对象的初始化工作。

如果一个类没有声明构造方法，也可以执行！因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。如果我们自己添加了类的构造方法（无论是否有参），Java 就不会再添加默认的无参数的构造方法了，这时候，就不能直接 new 一个对象而不传递参数了，所以我们一直在不知不觉地使用构造方法，这也是为什么我们在创建对象的时候后面要加一个括号（因为要调用无参的构造方法）。如果我们重载了有参的构造方法，记得都要把无参的构造方法也写出来（无论是否用到），因为这可以帮助我们在创建对象的时候少踩坑。


#### 构造方法有哪些特点？是否可被 override?

**特点：**
* 1.名字与类名相同。
* 2.没有返回值，但不能用 void 声明构造函数。
* 3.生成类的对象时自动执行，无需调用。

构造方法不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况。


#### this和super

this和super都是Java中的关键字

this表示的是当前对象，this可以调用方法、调用属性和指向对象本身。

this在Java中的使用一般有三种：指向当前对象

```java
public class Apple{
    int i = 0;

    Apple eatApple() {
        i++;
        return this;
    }

    public static void main(String[] args) {
        Apple apple = new Apple();
        apple.eatApple().eatApple();
    }
}
```

一个`eatApple()`方法竟然可以调用多次，在后面还可以继续调用，这就很神奇了，为啥呢？其实就是`this`在作祟，我在`eatApple()`方法中加了一个`return this`的返回值，也就是说哪个对象调用`eatApple()`方法都能返回对象的自身。

`this`还可以修饰属性，最常见的就是在构造方法中使用`this`，如下所示

```java
public class Apple{
    private int num;
    
    public Apple(int num) {
        this.num = num;
    }

    public static void main(String[] args) {
        Apple apple = new Apple(10);
    }
}
```

`main` 方法中传递了一个int值为10的参数，并把这个数量赋给了num全局变量。

`this` 还可以和构造函数一起使用，充当一个全局关键字的效果

```java
class Apple{
    private int num;
    private String color;

    public Apple(int num) {
        this(num, "红色");
    }

    public Apple(int num, String color) {
        this.num = num;
        this.color = color;
    }

    public int getNum() {
        return num;
    }

    public String getColor() {
        return color;
    }
}

public class Main {

    public static void main(String[] args) {
        Apple apple = new Apple(10);
        System.out.println(apple.getNum() + "   " + apple.getColor());
    }
}
```

输出：
```
10   红色
```

你会发现上面这段代码使用的不是`this`,而是`this(参数)`。它相当于调用了其他构造方法，然后传递参数进去。**这里值得注意的一点：this()必须放在构造函数的第一行，否则编译不通过。**

如果你把this理解为一个指向自身的一个引用，那么super就是指向父类的一个引用。super关键字和this一样，你可以使用`super.对象`来引用父类的成员。

```java
class Fruit {
    public int num;
    public String color;

    public void eat() {
        System.out.println("eat Fruit");
    }
}

class Apple extends Fruit {

    @Override
    public void eat() {
        super.num = 10;
        System.out.println("eat " + num + " Apple");
    }
}

public class Main {

    public static void main(String[] args) {
        Apple apple = new Apple();
        apple.eat();
    }
}
```

输出：

```
eat 10 Apple
```

同样也可以使用`super(参数)`来调用父类的构造函数。

下面汇总了this关键字和super关键字的比较。

| 关键字 | this | super |
|--|--|--|
| 调用方式 | 调用本类中的属性、构造函数、方法 | 调用父类中的属性、构造函数、方法 |
| 调用位置 | 构造函数第一行，其他可自行指定 | 构造函数第一行，其他可自行指定 |
| 调用次数 | 一个构造函数只能调用一次 | 一个构造函数只能调用一次 |


#### 面向对象的三大特征

##### 封装

在面向对象程式设计方法中，封装（英语：Encapsulation）是指一种将抽象性函式接口的实现细节部分包装、隐藏起来的方法。

封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。

要访问该类的代码和数据，必须通过严格的接口控制。

封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。

适当的封装可以让程式码更容易理解与维护，也加强了程式码的安全性。

**封装的优点：**
* 1.良好的封装能够减少耦合
* 2.类内部的结构可以自由地修改
* 3.可以对成员变量进行更精确的控制
* 4.隐藏信息，实现细节

**访问控制符**

| | 同一类 | 同一个包 | 不同包的子类 | 不同包 |
|--|--|--|--|--|
| public | yes | yes | yes | yes |
| protected | yes | yes | yse(super) | no |
| default | yes | yes | no | no |
| private | yes | no | no | no |

**1.public**

* 可以修饰类,表示这个类可以被引入到任何地方使用
* 可以修饰属性和方法,表示这个属性和方法，可以在本类，本包其它类中，其它包的类中使用

**2.protected**

* 不能用来修饰类
* 可以修饰属性和方法,表示这个属性和方法，不能在其它包中访问，可以在本包中的其它类，可以在其它包的子类通过this/super访问

**3.default**

不加任何访问控制符就表示default

* 可以修饰类，表示该类只能在当前包中使用
* 可以修饰方法，属性，表示属性和方法 只能在当前包中的类里使用

**4.private**

* 可以修饰方法，属性，表示属性和方法 只能在当前类里使用

**何为完全封装**

对所有的属性进行private隐藏，然后为这些属性提供get/set方法来存取访问

**get/set方法的写法**

* boolean值 setXxx, isXxx
* 其它类型  setXxx, getXxx

##### 继承

不同类型的对象，相互之间经常有一定数量的共同点。例如，小明同学、小红同学、小李同学，都共享学生的特性（班级、学号等）。同时，每一个对象还定义了额外的特性使得他们与众不同。例如小明的数学比较好，小红的性格惹人喜爱；小李的力气比较大。继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。 


**关于继承如下 3 点请记住：**
* 子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，**只是拥有。**
* 子类可以拥有自己属性和方法，即子类可以对父类进行扩展。
* 子类可以用自己的方式实现父类的方法。（重写）。


##### 多态

######  1.多态概述
   1.面向对象程序设计的三大支柱是封装、继承和多态
   
   2.多态就是对同一个对象，在**不同**时刻表现出来的**不同**形态
   
   3.多态 **现实意义**    理解：
   * 电脑上的F1按键，当不打开任何文件点击F1显示的是系统的帮助文档，当打开word文档点击F1显示的是word文档的帮助，同一个按钮但是能实现不同的处理方式
   * 现实中同一个事物通常会出现多种形态，比如说我自己，我在本质上是一个**人**，在学校里我是一个**学生**，这就是一种多态。
   * Java作为面向对象的语言，同样可以描述一个事物的多种形态。如Student类继承了Person类，一个Student的对象便既是Student，又是Person。

4.多态意味着父类的变量可以指向子类对象。

5.多态的前提条件
* 要有继承关系
* 要有方法重写
* 要有父类引用指向子类对象

6.多态的定义格式
* 父类类型 变量名=new 子类类型();

**总而言之，多态就是同样的引用调用同样的方法却做了不同的事情**

###### 2.多态的好处

**1.可以把不同的子类对象都当作父类来看，可以屏蔽不同子类对象之间的差异，写出通用的代码，做出通用的编程。**

**2.统一调用标准，一切向父类看齐。**

**3.提高了程序的扩展性和可维护性。**

###### 3.多态转型
$\color{red}{多态的转型一共分为两种：向上转型和向下转型}$

**向上转型：**
* 多态本身就是一个向上转型的过程
* 使用格式：父类类型 变量名=new 子类类型()
* 适用场景：当不需要面对子类类型时，通过提高扩展性，或者使用父类的功能就能完成相应的操作


**向下转型：**
* 一个已经向上转型的子类对象可以使用强制类型转换的格式，将父类引用类型转为子类引用各类型
* 使用格式：子类类型 变量名=（子类类型） 父类类型的变量
* 适用场景：当要使用子类特有功能时

$\color{red}{向下转型的注意事项：}$

* 向下转型的前提是父类对象指向的是子类对象（也就是说，在向下转型之前，它得先向上转型）
* 向下转型只能转型为本类对象（比如学生类是不能转换成老师类的）。 

######  4.多态案例

```java
public class test {
    public static void main(String[] args) {
    	People p = new Students();       //父类引用指向子类对象
    	p.id();
    }
}
class People{
    public void id(){
        System.out.println("人");
    }
}
class Students extends People{     //继承
    public void id(){              //重写
        System.out.println("学生");
    }
    public void study(){
        System.out.println("好好学习");
    }
}
```
**这段代码运行后的结果是**`学生`

$\color{red}{当使用多态方式调用方法时，首先检查父类中是否有该方法，}$
$\color{red}{如果没有，则编译错误；如果有，再去调用子类的同名方法。}$

比如我们在`p.id();`下一行加上`p.study();`

```java
public class test {
    public static void main(String[] args) {
    	People p = new Students();
    	p.id();
    	p.study();
    }
}
```
**此时编译器会报study()方法没有定义的错误，其实这样写已经违反了多态的前提条件：要有方法重写。因为编译器在People类中找不到study()方法，所以就不满足多态的条件**

**如果要调用study()方法，就要用到上面讲的的向下转型来实现子类的特有功能**

```java
public class test {
    public static void main(String[] args) {
    	People p = new Students();
    	p.id();
    	Students st = (Students) p;
    	st.study();
    }
}
class People{
    public void id(){
        System.out.println("人");
    }
}
class Students extends People{
    public void id(){
        System.out.println("学生");
    }
    public void study(){
        System.out.println("好好学习");
    }
}
```

**接下来看一下完整的样例来帮助理解**

```java
public class test {
    public static void main(String[] args) {
    	People p1 = new People();
    	People p2 = new Students();
    	People p3 = new Teachers();
    	p1.id();
    	p2.id();
    	Students st = (Students) p2;
    	st.study();
    	p3.id();
    	Teachers th = (Teachers) p3;
    	th.teach();
    }
}
class People{
    public void id(){
        System.out.println("人");
    }
}
class Students extends People{
    public void id(){
        System.out.println("学生");
    }
    public void study(){
        System.out.println("好好学习");
    }
}
class Teachers extends People{
    public void id(){
        System.out.println("老师");
    }
    public void teach(){
        System.out.println("认真授课");
    }
}
```
这段代码最后输出的结果是

```java
人
学生
好好学习
老师
认真授课
```

#### 组合

组合其实不难理解，就是将对象引用置于新类中即可。组合也是提高类的复用性的一种方式。如果你想让类具有更多的扩展功能，你需要记住一句话：**多用组合，少用继承**。

```java
public class SoccerPlayer {

    private String name;
    private Soccer soccer;

}

public class Soccer{

    private String soccerName;
}
```

代码中`SoccerPlayer`引用了`Soccer`类，通过引用`Soccer`类来达到调用`Soccer`中的属性和方法。

组合和继承是有区别的，它们的主要区别如下：

| 特征 | 组合 | 继承 |
|--|--|--|--|
| 关系 | 组合是一种 has - a的关系，可以理解为有一个 | 继承是一种 is - a的关系，可以理解为是一个 |
| 耦合性 | 组合的双方是一种松耦合的关系 | 继承双方紧耦合 |
| 是否具有多态 | 组合不具备多态和向上转型 | 继承是多态的继承，可以实现向上转型 |
| 时期 | 组合是运行期绑定 | 继承是编译期绑定 |




